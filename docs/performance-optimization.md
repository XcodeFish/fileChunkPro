# fileChunkPro 性能优化文档

## 内存管理策略

fileChunkPro 采用了多种策略来优化内存使用，尤其是在处理大文件时，有效避免内存溢出问题。

### 内存监控系统

通过 `MemoryManager` 类实现的实时内存监控系统具有以下特点：

- **内存使用追踪**：周期性监控堆内存使用情况，记录内存增长趋势
- **内存增长率计算**：根据采样数据计算内存增长速度，用于预测潜在内存问题
- **内存不足检测**：当内存使用率超过70%时触发内存警告

示例用法：

```typescript
// 开始内存监控
MemoryManager.startMonitoring();

// 检查是否在低内存状态
if (MemoryManager.isLowMemory()) {
  // 执行内存优化措施
}

// 获取内存增长率
const growthRate = MemoryManager.getMemoryGrowthRate();

// 结束监控
MemoryManager.stopMonitoring();
```

### 自适应分片大小

系统根据多种因素动态调整分片大小，以达到性能和内存使用的平衡：

- **文件大小适配**：根据文件总大小调整基础分片大小

  - 小于10MB文件：使用1MB分片
  - 10-100MB文件：使用5MB分片
  - 100MB-1GB文件：使用10MB分片
  - 大于1GB文件：使用20MB分片

- **内存状态适配**：根据当前内存状况调整

  - 当内存增长率过高时，分片大小会自动缩小
  - 低内存状态下，限制最大分片为5MB

- **设备和环境适配**：
  - 在性能较弱设备上使用更小的分片
  - 不同环境（浏览器、小程序）使用不同的分片策略

### 垃圾回收优化

为避免长时间运行分片创建过程导致内存累积，系统实现了主动垃圾回收建议：

- 在创建大量分片前先建议进行垃圾回收
- 每创建50个分片后检查内存状态
- 在低内存状态下执行垃圾回收操作
- 任务执行前的内存释放建议

```typescript
// 在关键操作前建议进行垃圾回收
MemoryManager.suggestGarbageCollection();
```

## 大文件处理策略

### 流式处理

对于大文件（>100MB），fileChunkPro 会自动启用流式处理以显著降低内存使用：

- **惰性分片创建**：仅创建分片元数据，不立即加载全部内容
- **流式读取**：利用 `Blob.prototype.stream()` API 实现流式读取
- **延迟求值**：通过 getter 方式实现分片内容的按需获取

启用流式处理的示例：

```typescript
const chunkPlugin = new ChunkPlugin({
  useStreams: true, // 启用流式处理
  streamChunkSize: 2 * 1024 * 1024, // 设置流处理的分片大小为2MB
});
```

### 自适应并发控制

系统能够根据多种因素动态调整上传并发数：

- **设备性能适配**：根据设备核心数调整最大并发
- **网络状态适配**：
  - 4G网络：默认4并发
  - 3G网络：默认2并发
  - 较慢网络：默认1并发
  - 启用节电模式时：强制1并发
- **内存状态适配**：在低内存状况下降低并发
- **网络质量监测**：根据上传成功率和时间动态调整

### 大文件策略自动选择

对于不同大小的文件，系统会自动选择不同的处理策略：

| 文件大小  | 分片大小 | 并发数 | 是否使用流 | 是否使用Worker |
| --------- | -------- | ------ | ---------- | -------------- |
| <100MB    | 1-5MB    | 4      | 否         | 是             |
| 100-500MB | ≤10MB    | 3      | 可选       | 是             |
| 500MB-1GB | ≤15MB    | 2      | 是         | 是             |
| >1GB      | ≤20MB    | 2      | 是         | 视内存状况     |

### 网络状态适应

系统会根据网络状态调整上传策略：

- **快速网络**：优先选择较大分片，提高吞吐量
- **慢速网络**：选择较小分片，提高成功率
- **不稳定网络**：降低并发，增加重试间隔
- **重试策略**：采用指数退避算法，逐步增加重试间隔

## 性能测试结果

### 分片性能测试

| 文件大小 | 分片数量 | 分片时间 | 内存增长 | 内存使用率 |
| -------- | -------- | -------- | -------- | ---------- |
| 100MB    | 20       | ~300ms   | ~20MB    | ~15%       |
| 500MB    | 50       | ~800ms   | ~50MB    | ~25%       |
| 1GB      | 100      | ~2s      | ~100MB   | ~35%       |

> 注：测试环境为Chrome 94，8GB RAM，4核CPU

### 上传性能测试

| 文件大小 | 分片大小 | 并发数 | 平均上传速度 | 内存峰值 |
| -------- | -------- | ------ | ------------ | -------- |
| 100MB    | 5MB      | 3      | ~5MB/s       | ~50MB    |
| 500MB    | 10MB     | 2      | ~4MB/s       | ~80MB    |
| 1GB      | 20MB     | 2      | ~4MB/s       | ~150MB   |

## 性能优化最佳实践

### 开发者配置选项

为获得最佳性能，开发者可以调整以下配置：

```typescript
const uploader = new UploaderCore({
  // 文件大小相关
  chunkSize: 'auto', // 自动选择最优分片大小
  maxFileSize: 2 * 1024 * 1024 * 1024, // 设置最大文件限制（2GB）

  // 并发控制
  concurrency: 3, // 初始并发数，也可以设为'auto'

  // 内存优化
  useStreams: true, // 启用流式处理
  useWorker: true, // 使用Worker线程

  // 网络优化
  retryCount: 3, // 失败重试次数
  timeout: 30000, // 请求超时时间(ms)

  // 性能监控
  enablePerformanceTracking: true, // 启用性能追踪
});
```

### 用户体验优化建议

- **分片进度提示**：显示每个分片的进度而不仅是总进度
- **动态调整提示**：当系统自动调整策略时提供友好提示
- **上传速度显示**：显示实时上传速度和预计剩余时间
- **内存使用提示**：在内存使用接近限制时提供警告
- **离线支持**：支持中断后继续上传功能

## 高级配置与调优

对于特殊场景，可以进行更深入的性能调优：

```typescript
// 手动调整任务调度器中的并发数
uploader.taskScheduler.setConcurrency(4);

// 使用低内存配置
const lowMemoryConfig = {
  chunkSize: 2 * 1024 * 1024, // 固定小分片
  concurrency: 1, // 最低并发
  useStreams: true, // 强制使用流
  useWorker: false, // 禁用Worker
  enableProgressiveUpload: true, // 启用渐进式上传
};
```

### 特殊场景优化

1. **弱网环境**：

   - 减小分片大小（1-2MB）
   - 降低并发（1-2）
   - 增加重试次数和超时时间

2. **低端设备**：

   - 避免使用Worker
   - 使用最小分片
   - 限制文件大小

3. **企业级大文件传输**：
   - 增加分片大小（最多50MB）
   - 提高并发（最多8）
   - 启用预上传验证

通过以上策略，fileChunkPro能够在各种环境下高效、稳定地处理文件上传，同时保持较低的内存占用和良好的性能表现。
